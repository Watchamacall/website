<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!--Font-->
  <link rel="stylesheet" href="MindSlayer_files/font-awesome.min.css">

  <!--Bootstrap-->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">  
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
  <!---Prism---->
  <script src="JavaScript/prism.js"></script>
  <link rel="stylesheet" href="CSS/prism.css">
  <!--Custom-->
  <link rel="stylesheet" href="CSS/stylesheet.css">
  <script src="JavaScript/scripts.js"></script>
  <link href="MindSlayer_files/css.css" rel="stylesheet">
  <link href="CSS/ProjectStylesheet.css" rel="stylesheet">
</head>

<body data-new-gr-c-s-check-loaded="8.904.0" data-gr-ext-installed="">
  <div class="topnav" id="myTopnav">
    <a href="./index.html">Home</a>
    <a href="MindSlayer.html">MindSlayer</a>
    <a href="#" class="active">Hole In The Wall</a>
    <a href="DreamCollection.html">Dream Collection</a>
    <a href="javascript:void(0);" class="icon" onclick="NavbarOpen()">
      <i class="fa fa-bars"></i>
    </a>
  </div>
  <!--Carousel-->
  <div class="container">
    <br>
    <div id="myCarousel" class="carousel slide" data-ride="carousel">
      <!-- Indicators -->
      <ol class="carousel-indicators">
        <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
        <li data-target="#myCarousel" data-slide-to="1"></li>
        <li data-target="#myCarousel" data-slide-to="2"></li>
      </ol>

      <!-- Wrapper for slides -->
      <div class="carousel-inner" role="listbox">

        <div class="item active">
          <video autoplay loop controls>
            <source src="images/SFAS2023/FirstLevel.mp4" type="video/mp4">
          </video>
          <div class="carousel-caption">
            <h3>First Level of the game</h3>
            <p>Showing the first level of the game</p>
          </div>
        </div>
        <div class="item">
          <video autoplay loop controls>
            <source src="images/SFAS2023/FourToFiveSides.mp4" type="video/mp4">
          </video>
          <div class="carousel-caption">
            <h3>Changing Sides</h3>
            <p>Going from 4 sides to 5 sides on an object</p>
          </div>
        </div>
        <div class="item">
          <video autoplay loop controls>
            <source src="images/SFAS2023/FinalLevelWithWinScreen.mp4" type="video/mp4">
          </video>
          <div class="carousel-caption">
            <h3>Win Screen</h3>
            <p>Completing the final level to the win screen</p>
          </div>
        </div>
        <!-- <div class="item">
                  <img src="./Images/MindSlayer/MindSlayerImage.png" alt="Chania" width="460" height="345">
                  <div class="carousel-caption">
                    <h3>Chania</h3>
                    <p>The atmosphere in Chania has a touch of Florence and Venice.</p>
                  </div>
                </div>
              
                <div class="item">
                  <img src="./Images/MindSlayer/MindSlayerImage.png" alt="Flower" width="460" height="345">
                  <div class="carousel-caption">
                    <h3>Flowers</h3>
                    <p>Beautiful flowers in Kolymbari, Crete.</p>
                  </div>
                </div>
          
                <div class="item">
                  <img src="./Images/MindSlayer/MindSlayerImage.png" alt="Flower" width="460" height="345">
                  <div class="carousel-caption">
                    <h3>Flowers</h3>
                    <p>Beautiful flowers in Kolymbari, Crete.</p>
                  </div>
                </div> -->

      </div>

      <!-- Left and right controls -->
      <a class="left carousel-control" href="#myCarousel" role="button" data-slide="prev">
        <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
        <span class="sr-only">Previous</span>
      </a>
      <a class="right carousel-control" href="#myCarousel" role="button" data-slide="next">
        <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
        <span class="sr-only">Next</span>
      </a>
    </div>
  </div>

  <div class="projectDiv">
    <h1>Hole In The Wall</h1>
    <p>
      Hole in the Wall is a game about moving a shape to match the hole in the wall coming towards you. This project was created as part of Search For A Star 2023.
    </p>
  </div>

  <div class="projectDiv">
    <h3>Existing Codebase</h3>

  </div>
    <div class="projectDiv">
      <h3>Understanding The Codebase</h3>
      <p>
        When starting the challenge, the base code is all uncommented and required commenting to understand how each class and function worked.
        <br><br>
        If there were any parts of the code I couldn’t understand, I would use breakpoints within the IDE and go through the function bit by bit to understand how it worked, then commenting it all.
      </p>
    </div>
    <div class="sidebysideElement">
      <h3>Changing The Codebase</h3>
      <p>
        There were elements to the Codebase that were changed in order to work with the way the project was heading
        <br>
        An example of this would be the UI Elements, below is the original and what it was changed to
      </p>

      <div class="sidebyside">
        <div class="sidebysideElement">
          <h3>Original</h3>
          <code data-prismjs-copy="Copy this code snippet" class="language-cpp">
STBPlayerController.cpp

void ASTBPlayerController::CreateUI()
{
  Widgets.Init(nullptr, static_cast&#60;int&#62;(ESTBGameMode::NumModes));
  SetupScreen(ESTBGameMode::Intro, IntroClass, TEXT("Intro"));
  SetupScreen(ESTBGameMode::MainMenu, MenuClass, TEXT("MainMenu"));
  SetupScreen(ESTBGameMode::Settings, SettingsClass, TEXT("Settings"));
  SetupScreen(ESTBGameMode::Playing, PlayingClass, TEXT("Playing"));
  SetupScreen(ESTBGameMode::GameOver, GameOverClass, TEXT("GameOver"));
  SetupScreen(ESTBGameMode::Outro, OutroClass, TEXT("Outro"));
  ShowUI(ESTBGameMode::Intro);
}
          </code>
        </div>

        <div class="sidebysideElement">
          <h3>Changed</h3>
          <code data-prismjs-copy="Copy this code snippet" class="language-cpp">
STBPlayerController.cpp
void ASTBPlayerController::CreateUI()
{
  Widgets.Init(nullptr, static_cast&#60;int&#62;(ESTBGameMode::NumModes));
  SetupScreen();
  ShowUI(ESTBGameMode::Intro);
}

void ASTBPlayerController::SetupScreen(ESTBGameMode State, TSubclassOf&#60;UScreen&#62; Class, FName Name)
{
  UScreen* Screen = NewObject&#60;UScreen&#62;(this, Class, Name);
  Screen-&#62;bIsFocusable = true;
  Screen-&#62;SetOwningPlayer(this);
  Screen-&#62;AddToViewport(0);
  Widgets[static_cast&#60;int&#62;(State)] = Screen;
}

void ASTBPlayerController::SetupScreen()
{
  TArray&#60;TSubclassOf&#60;UScreen&#62;&#62; keys;
  UI_Classes.GenerateKeyArray(keys);

  for (size_t i = 0; i &#60; UI_Classes.Num(); i++)
  {
    SetupScreen(*UI_Classes.Find(keys[i]), keys[i], keys[i].Get()-&#62;GetFName());
  }
}
          </code>
        </div>
      </div>
      <div class="sidebyside">
        <div class="sidebysideElement">
          <code data-prismjs-copy="Copy this code snippet" class="language-cpp">
STBPlayerController.h
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "UI")
  TSubclassOf&#60;UScreen&#62; IntroClass;

UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "UI")
  TSubclassOf&#60;UScreen&#62; MenuClass;

UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "UI")
  TSubclassOf&#60;UScreen&#62; SettingsClass;

UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "UI")
  TSubclassOf&#60;UScreen&#62; PlayingClass;

UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "UI")
  TSubclassOf&#60;UScreen&#62; GameOverClass;

UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "UI")
  TSubclassOf&#60;UScreen&#62; OutroClass;
          </code>
        </div>
        <div class="sidebysideElement">
          <code data-prismjs-copy="Copy this code snippet" class="language-cpp">
STBPlayerController.h
/*
  * Array of all the classes UI 
*/
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="UI|General")
  TMap&#60;TSubclassOf&#60;UScreen&#62;, ESTBGameMode&#62; UI_Classes;
          </code>
        </div>
      </div>
      <p>
        The FProgressionLevelData was also changed to include the Mesh Generation data for each level, the code below shows the difference
      </p>
      <div class="sidebyside">
        <div class="sidebysideElement">
            <code data-prismjs-copy="Copy this code snippet" class="language-cpp">
USTRUCT(BlueprintType)
struct FProgressionLevelData
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TArray<FProgressionCharacterData> Characters;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FBoxSphereBounds BallBounds;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	float RequiredDistance;	
};
              </code>
        </div>
        <div class="sidebysideElement">
          <code data-prismjs-copy="Copy this code snippet" class="language-cpp">
USTRUCT(BlueprintType)
struct FProgressionLevelData
{
GENERATED_BODY()

/*
  * The Actors you want to spawn in to show (DEPRECATED)
*/
UPROPERTY(EditAnywhere, BlueprintReadOnly)
  TArray<FProgressionCharacterData> Characters;
/*
  * The Bounds in which the ball can spawn in
*/
UPROPERTY(EditAnywhere, BlueprintReadOnly)
  FBoxSphereBounds BallBounds;
/*
  * The distance for this level in which the player's mesh can be out (The Lower, The Stricter)
*/
UPROPERTY(EditAnywhere, BlueprintReadOnly)
  float Tolerance;	
/*
  * The amount of time in seconds it takes for the wall to reach the Player's Mesh
*/
UPROPERTY(EditAnywhere, BlueprintReadOnly)
  float TimeTillWallHit = 0.f;
/*
  * The amount of sides that are on the generated Mesh
*/
UPROPERTY(EditAnywhere, BlueprintReadOnly)
  int AmountOfSidesOnShape;
};
          </code>
        </div>
        
      </div>
      <p>
        A major change to the original codebase was changing the PlayingScreen Select_Implementation to select a vertex of an object instead of guessing, the code below shows the comparison.
      </p>
      <div class="sidebyside">
        <div class="sidebysideElement">
            <code data-prismjs-copy="Copy this code snippet" class="language-cpp">
void UPlayingScreen::Select_Implementation()
{
  if(PlayingState == EPlayingState::Guessing)
  {
    if(IsValid(PlayerController))
    {
      const bool bCorrect = PlayerController-&#62;TryMove();
      if(!bCorrect)
      {
        if(const UGameplay* Gameplay = PlayerController-&#62;GetGameplay())
        {
          const int Lives = Gameplay-&#62;GetLives();
          SetLives(Lives);
        }					
      }

      DoReveal(bCorrect);
    }
  }
  else if(PlayingState == EPlayingState::Shown)
  {
    Reset();
  }
}
            </code>
        </div>
        <div class="sidebysideElement">
          <code data-prismjs-copy="Copy this code snippet" class="language-cpp">
void UPlayingScreen::Select_Implementation()
{
  if (IsValid(PlayerController))
  {
    if (PlayingState == EPlayingState::Guessing)
    {
      
      FVector WorldLocation;
      FVector WorldDirection;

      //Since the GuessPosition origin is the center of the screen whilst the Deproject origin is top left, add the Viewport * .5f to center it and get accurate direction
      FVector2D ViewportSizeTotal;

      auto Viewport = GWorld-&#62;GetGameViewport();
      Viewport-&#62;GetViewportSize(ViewportSizeTotal);

      FVector2D AccuracyMulti = FVector2D(ViewportSizeTotal.X / 1920.f , ViewportSizeTotal.Y / 1080.f);

      FVector2D GuessPosition = (Cast&#60;UCanvasPanelSlot&#62;(Images[GuessImageIndex]-&#62;Slot)-&#62;GetPosition()* AccuracyMulti);
        

      ViewportSizeTotal *= .5f;
      ViewportSizeTotal = FVector2D(ViewportSizeTotal.X + GuessPosition.X, ViewportSizeTotal.Y + GuessPosition.Y);

      GetWorld()-&#62;GetFirstPlayerController()-&#62;SetMouseLocation(ViewportSizeTotal.X, ViewportSizeTotal.Y);

      FHitResult Hit;

      
      if (PlayerController-&#62;GetHitResultAtScreenPosition(ViewportSizeTotal, ECollisionChannel::ECC_WorldDynamic, false, Hit))
      {
        if (UStaticVertexCollider* Collider = Cast&#60;UStaticVertexCollider&#62;(Hit.GetComponent()))
        {
          PlayerController-&#62;SetSelectedVertex(Collider-&#62;VertexNo);
          Images[GuessImageIndex]-&#62;SetBrushTintColor(SelectedColor);
        }
      }
    }
    else if (PlayingState == EPlayingState::Shown) //After the whole part of the game
    {
      Reset();
    }
  }
}   
          </code>
        </div>
      </div>
      <p>
        The cursor selection within this had some trouble with it, when selecting the widget xy locations, they would not match the actual xy value of the world and would cause the game to not actually be playable. A fix was created by dividing the viewport by 1920 and 1080 for the x and y values respectively. The code above shows this implementation.
      </p>
      
      <h3>Generating Mesh</h3>
      <p>
        This class was created with the sole purpose of creating the procedural mesh which is shown on the screen
        <br>
        This class is inherited from <a href=”#”>UProceduralMeshComponent</a> and adds variables for the mesh such as Triangles, Verticies, UVs. Within this class there are functions for generating the mesh based on these variables.
        <br>
        The code below is the UpdateMesh function
      </p>

      <code data-prismjs-copy="Copy this code snippet" class="language-cpp">
void UProGenMeshBase::UpdateMesh(int SidesOnShape, UStaticMesh* ColliderMesh)
{

  if (SidesOnShape &#60;= 2)
  {
    UE_LOG(LogTemp, Display, TEXT("Shape is 2 or less sides, will crash program!"));
    return;
  }

  //Clearing the fields to allow for new Shapes to be created
  Triangles.Empty();
  Verticies.Empty();
  VertexColliders.Empty();
  Normals.Empty();
  UV0.Empty();
  Tangents.Empty();
  VertexColours.Empty();
  OnWallHit.Empty();

  //Setting all the Verticies in the shape and equating them to a circle
  float Angle = 360.f / SidesOnShape;

  for (size_t CurrentSide = 0; CurrentSide &#60; SidesOnShape; CurrentSide++)
  {
    //Verticies
    float CurAngle = FMath::FMath::DegreesToRadians(Angle * CurrentSide); //Change to Radians since Sin and Cos use Radians and not Degrees
    float X = FMath::Sin(CurAngle);
    float Y = FMath::Cos(CurAngle);
    Verticies.Add(FVector(X, 0.f, Y));

    //Setting the collider for the vertex
    FString CurrentColliderName = FString::Format(TEXT("Collider For Vertex {0}"), TArray&#60;FStringFormatArg&#62;{CurrentSide});
    UStaticVertexCollider* CurrentCollider = NewObject&#60;UStaticVertexCollider&#62;(this-&#62;GetOwner(), (FName)CurrentColliderName);
    CurrentCollider-&#62;SetMaterial(0, VertexColliderMaterial);

    //Attaching Collider
    CurrentCollider-&#62;AttachToComponent(this, FAttachmentTransformRules::SnapToTargetNotIncludingScale);
    CurrentCollider-&#62;RegisterComponent();

    //Setting World Transform
    FTransform ColliderTransform = FTransform(FRotator(0.f, 0.f, -90.f), this-&#62;GetComponentLocation() + FVector(X, 0.f, Y), VertexColliderScale);
    CurrentCollider-&#62;SetWorldTransform(ColliderTransform);

    //Setting Mesh and Vertex Number
    CurrentCollider-&#62;SetStaticMesh(ColliderMesh);
    CurrentCollider-&#62;VertexNo = CurrentSide;

    VertexColliders.Add(CurrentCollider);

    if (bCanSendRay)
    {
      //Spawning the Collider which will be shown on the wall mesh
      CurrentColliderName = FString::Format(TEXT("Visual For Current Vertex {0}"), TArray&#60;FStringFormatArg&#62;{CurrentSide});
      UStaticMeshComponent* MeshShown = NewObject&#60;&#60;&#60;UStaticMeshComponent&#62;(this-&#62;GetOwner(), (FName)CurrentColliderName);

      //Attaching Collider
      MeshShown-&#62;AttachToComponent(this, FAttachmentTransformRules::SnapToTargetNotIncludingScale);
      MeshShown-&#62;RegisterComponent();

      //Setting World Transform
      ColliderTransform = FTransform(FRotator(0.f, 0.f, -90.f), this-&#62;GetComponentLocation(), ShownColliderScale);
      MeshShown-&#62;SetWorldTransform(ColliderTransform);

      //Setting the mesh for this and the material
      MeshShown-&#62;SetStaticMesh(ShownColliderMesh);
      MeshShown-&#62;SetMaterial(0, ShownColliderMaterial);

      OnWallHit.Add(MeshShown);
    }
    //Normals
    Normals.Add(FVector(1.f, 0.f, 0.f));
    //UV0
    UV0.Add(FVector2D(X, Y));
    //Tangents
    Tangents.Add(FProcMeshTangent(0.f, 1.f, 0.f));
    //Linear Colour
    VertexColours.Add(FLinearColor(.75f, .75f, .675f, 1.f));
  }
  //Setting all the Triangles
  //Minus the two since we only need Sides - 2 Tries, will cause IndexOutOfArray crashes
  for (size_t CurrentTri = 0; CurrentTri &#60; SidesOnShape - 2; CurrentTri++)
  {
    Triangles.Add(0);
    Triangles.Add(CurrentTri + 1);
    Triangles.Add(CurrentTri + 2);
  }
  CreateMesh();
}
      </code>

</body>

</html>

<!--
  Hole in the Wall
    Hole in the Wall is a game created for the Search For a Star 2023 Game Jam. It involves having to match a your shape to the hole in the wall, you pass if you get within a range to the wall or lose a life if not.

  Mesh Generation
    In order for this game to have been created, a mesh would have to be generated during runtime. Luckily, Unreal has a <a>UProceduralMesh class that allows for custom mesh to be created. Inheriting this class allowed for the needed parameters to be added as variables and edited during runtime.
    
    (Side by side)
    
    Existing Codebase
      The first job when completing this jam is knowing how the existing codebase works. To do this, I commented a lot of the variables and functions in regards to whats in the functions and what they are. (Code)
    
    Generating Mesh
      Generating mesh for the main game mechanics was essential, the <a>UProceduralMesh class has a function called <a>CreateMesh_LinearColor which allows for all the difficult part of rendering the mesh to be done automatically.
      In order to get the verticies locations, I used a circle as a base and utilised trigonometry to figure out where on the outer circle they should be. (Code).
      Triangles were simple enough with a for loop iterating adding the first vertex then the CurrentTri + 1 and CurrentTri + 2 (Code)
      There is no need for special code for texture generation since there is only simple shapes being constructed. (Code)
    
    (/Side by side)

    
    
  
-->